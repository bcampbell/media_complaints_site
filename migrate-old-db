#!/usr/bin/env python
import os
import sys
import datetime
import re
import base64
import pickle

from django.core.management import setup_environ
import settings

setup_environ(settings)

from django.core.exceptions import ObjectDoesNotExist

from cases.models import *

import MySQLdb
import MySQLdb.cursors

_conn = None


CASEMAPFILE = 'case_map'



def get_article_id( old ):
    """ get pcc article id from urls """
    urls = get_urls(old, 'pcc.org.uk' )
    if len(urls)==0:
        return None
    assert len(urls)==1
    url = urls[0]

    id_pat = re.compile( 'article=(.+?)(?:http://.*)?$' )
    m = id_pat.search( url )
    if m is None:
#        print "%s: WARNING: couldn't extract article id from url '%s'" %( old['id'],url )
        return None

    encoded_id = m.group(1)
    if not encoded_id.endswith('=='):
        # missing padding
        assert len(encoded_id) == 6
        encoded_id = encoded_id + "=="
    article_id = int( base64.urlsafe_b64decode( encoded_id ) )
    return article_id





def find_cases( old ):
    """ find case(s) in new db, corresponding to the ones in the old one """
    cases = []

    method = "not found"

    legacy_id = get_article_id( old )
    #print "legacy_id: ",legacy_id
    if legacy_id is not None:
        cases = Case.objects.filter( legacy_id=legacy_id )

    if not cases:
        # use complaint text to resolve:
        if old['complaint'].strip() == '':
            pass
#            print "%s: blank" %(old['id'],)
        else:
#            print "using complaint"
#            print old['complaint'].split()
            cases = Case.objects.filter( complaint__icontains=old['complaint'].strip() )

    if not cases:
        # try using complainant and complaint_about:
        cases = Case.objects.filter(
            complainants__name__iexact=old['complainant'].strip(),
            defendants__name__iexact=old['complaint_about'].strip() )
        if len(cases)==1:
            pass
#            print "%s: matched using complainant/defendant" % (old['id'],)
        elif len(cases)>1:
            # if ambiguous, forget it.
#            print "%s: matched using complainant/defendant but ambiguous, so discarding" % (old['id'],)
            cases = []
    #print old['id'], method

    return [ case.pk for case in cases ]


def get_urls(old, match=None):
    """ get list of urls attached to story in old db """
    urls = []
    for f in ( 'url_of_story', 'url_of_story_2' ):
        url = old[f]
        if url is None:
            continue
        url = url.strip()
        if url=='':
            continue
        if (match is not None) and match in url:
            urls.append( url )
    return urls



def build_case_map():
    """ build mapping of old db id to new db id(s) """
    print "Building case map..."
    cursor = _conn.cursor()
    cursor.execute ("SELECT id,complaint,complainant,complaint_about,url_of_story,url_of_story_2 FROM complaints WHERE complaint_body='PCC'")

    # mapping from old db id to new cases in django db
    case_map = {}
    reverse_map = {}

    found = 0
    total = 0
    for row in cursor:
        cases = find_cases( row )
#        if len(cases)>1:
#            print "%s: WARNING: multiple cases" % (row['id'],)

        assert row['id'] not in case_map
        case_map[ row['id'] ] = cases
        if len(cases)>0:
            found=found+1
#            print row['id'] , "->", cases
        else:
            print "http://vernon.mediastandardstrust.org/~ben/complaints/index.php?action=view&pk=%s" % (row['id'],)

        total=total+1

    print found,"/",total
    cursor.close()
    return case_map




def get_complaint_keywords( old ):

    raw = old['complaint_keyword']
    if old['complaint_keyword_2']:
        raw = raw + ',' + old['complaint_keyword_2']
    if old['complaint_keyword_3']:
        raw = raw + ',' + old['complaint_keyword_3']

    fixups = {
            'Dicrimination': 'Discrimination',
            'Deat': 'Death',
            'Factual Error': 'Factual error',
            'Inaccuray': 'Inaccuracy',
            'Photogragph': 'Photograph',
            'Photographs': 'Photograph',
            'Photography': 'Photograph',
            'Relationship': 'Relationships',
            'Right to Reply': 'Right to reply',
            }
    tags = raw.split(',')
    tags = [ t.strip() for t in tags ]
    tags = [ t for t in tags if t ]
    tags = [fixups.get(t,t) for t in tags]
    tags = list( set(tags) )    #uniquify
    return tags


def add_tags( case, tags ):
    for t in tags:
        tag_obj, created = Tag.objects.get_or_create( name__iexact=t )
        tag_obj.save()
        case.tags.add( tag_obj )


def get_related_cases( old,case_map ):
    related = set()

    raw = old['related_complaint']

    # "382-8" => "382-388"
    raw = re.sub( r'\b(\d+)(\d)-(\d)\b', r'\1\2-\1\3', raw )

    # 1258-1261 => "1258,1259,1260,1261"
    def repl( m ):
        return ','.join( [str(i) for i in range( int(m.group(1)),int(m.group(2))+1 ) ] )
    raw = re.sub( r'\b(\d+)-(\d+)\b', repl, raw )

#    if raw:
#        print old['id'], "---->", raw

    for r in raw.split(','):
        r=r.strip()
        if r == '':
            continue
        old_id = int(r)
        new_id = case_map[old_id]
        related.update(new_id)
#    if raw:
#        print old['id'], "====>", related
    return related



def add_related_cases( case, related_ids ):

    changed = False

    for id in related_ids:
        if id==case.pk or case.related_cases.filter(pk=id).count()>0:
            continue
        else:
            print "%s: added related case %s" % (case.id, id )
            case.related_cases.add( Case.objects.get(pk=id) )
            changed = True
    return changed



def main():
    global _conn

    _conn = MySQLdb.connect( host = "",
                            user = "root",
                            passwd = "",
                            db = "complaints",
                            cursorclass=MySQLdb.cursors.DictCursor )

    if len(sys.argv)>1 and sys.argv[1] == 'build_case_map':
        case_map = build_case_map()
        outfile = open( CASEMAPFILE, 'wb' )
        pickle.dump( case_map, outfile )
        outfile.close()
        print "wrote ", CASEMAPFILE
        sys.exit(0)


    f = open( CASEMAPFILE, 'rb' )
    case_map = pickle.load( f )
    f.close()

    print "add tags, summaries.."
    cursor = _conn.cursor()
    cursor.execute ("SELECT * FROM complaints WHERE complaint_body='PCC'")
    for row in cursor:
        tags = get_complaint_keywords( row )
        related = get_related_cases( row,case_map)

#        print row['id']
        cases = case_map[row['id']]
        for case_id in cases:
            case = Case.objects.get( pk=case_id )
            if tags and case.tags.count()==0:
                print "%s: case %d: add tags" % (row['id'],case.pk,)
                add_tags( case, tags )
            if row['complaint_title'].strip() and case.summary == '':
                case.summary = row['complaint_title'].strip()
                print "%s: case %d: set summary" % (row['id'],case.pk,)
                case.save()


            # add split cases as related cases:

            all_related = related.union( set([ c for c in cases if c != case_id ]) )
            if all_related:
#                print "all_related: ", all_related
                add_related_cases( case, related )

#            if related_case_ids:
#                print cases, related_case_ids

    cursor.close()

    _conn.close()

main()

